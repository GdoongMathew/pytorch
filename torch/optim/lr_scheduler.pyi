from typing import Any, Callable, Dict, Iterable, List, Optional, Sequence, Union, NoReturn

from .optimizer import Optimizer

class _SchedulerBase:
    optimizer: Optimizer = ...
    def state_dict(self) -> Dict[str, Any]: ...
    def load_state_dict(self, state_dict: Dict[str, Any]) -> None: ...
    def step(self, epoch: Optional[int] = ..., **kwargs) -> None: ...


class Scheduler(_SchedulerBase):
    param_groups: Sequence[Dict[str, Any]] = ...
    base_targets: List[Dict[str, Any]] = ...
    targets: Sequence[str] = ...
    last_targets: List[Dict[str, Any]] = ...
    last_step: int = ...
    total_iters: Optional[int] = ...
    def __init__(
        self,
        optimizer: Optimizer,
        param_groups: Optional[Sequence[Dict[str, Any]]] = ...,
        last_step: int = ...,
        total_iters: Optional[int] = ...,
    ) -> None: ...
    def update_targets(self, **kwargs) -> NoReturn: ...
    def step(self, epoch: Optional[int] = ..., **kwargs) -> None: ...


class ComposeScheduler(_SchedulerBase):
    schedulers: Sequence[Scheduler] = ...
    last_step: int = ...
    total_iters: Optional[int] = ...
    last_targets: Sequence[Dict[str, Any]] = ...
    def __init__(
        self,
        schedulers: Sequence[Scheduler],
        total_iters: Optional[int] = ...,
        last_step: int = ...,
    ) -> None: ...

    def step(self, epoch: Optional[int] = ..., **kwargs) -> None: ...
    def step_schedulers(self, *, step: int, **kwargs) -> None: ...
    def state_dict(self) -> Dict[str, Any]: ...
    def load_state_dict(self, state_dict: Dict[str, Any]) -> None: ...


class _LRScheduler(Scheduler): ...


class LambdaLR(Scheduler):
    lr_lambdas: List[Callable[[int], float]] = ...
    def __init__(
        self,
        optimizer: Optimizer,
        lr_lambda: Union[Callable[[int], float], List[Callable[[int], float]]],
        **kwargs: Any,
    ) -> None: ...


class MultiplicativeLR(LambdaLR): ...


class StepLR(Scheduler):
    step_size: int = ...
    gamma: float = ...
    def __init__(
        self,
        optimizer: Optimizer,
        step_size: int,
        gamma: float = ...,
        **kwargs: Any,
    ) -> None: ...


class MultiStepLR(Scheduler):
    milestones: Iterable[int] = ...
    gamma: float = ...
    def __init__(
        self,
        optimizer: Optimizer,
        milestones: Iterable[int],
        gamma: float = ...,
        **kwargs: Any,
    ) -> None: ...


class ConstantLR(Scheduler):
    factor: float = ...
    def __init__(
        self,
        optimizer: Optimizer,
        factor: float = ...,
        total_iters: int = ...,
        **kwargs: Any,
    ) -> None: ...


class LinearLR(Scheduler):
    start_factor: float = ...
    end_factor: float = ...
    def __init__(
        self,
        optimizer: Optimizer,
        start_factor: float = ...,
        end_factor: float = ...,
        total_iters: int = ...,
        **kwargs: Any,
    ) -> None: ...


class ExponentialLR(Scheduler):
    gamma: float = ...
    def __init__(
        self,
        optimizer: Optimizer,
        gamma: float,
        **kwargs: Any,
    ) -> None: ...

class ChainedScheduler(ComposeScheduler): ...


class SequentialLR(ComposeScheduler):
    milestones: Sequence[int] = ...
    def __init__(
        self,
        schedulers: Sequence[Scheduler],
        milestones: Sequence[int],
        **kwargs: Any,
    ) -> None: ...


class CosineAnnealingLR(Scheduler):
    eta_min: float = ...
    def __init__(
        self,
        optimizer: Optimizer,
        total_iters: int,
        eta_min: float = ...,
        **kwargs,
    ) -> None: ...

class ReduceLROnPlateau(Scheduler):
    factor: float = ...
    min_lrs: List[float] = ...
    patience: int = ...
    cooldown: int = ...
    cooldown_counter: int = ...
    mode: str = ...
    threshold: float = ...
    threshold_mode: str = ...
    best: Optional[float] = ...
    num_bad_iters: Optional[int] = ...
    mode_worse: Optional[float] = ...
    eps: float = ...
    def __init__(
        self,
        optimizer: Optimizer,
        param_group: Optional[Dict[str, Any]] = ...,
        mode: str = ...,
        factor: float = ...,
        patience: int = ...,
        threshold: float = ...,
        threshold_mode: str = ...,
        cooldown: int = ...,
        min_lr: Union[Sequence[float], float] = ...,
        eps: float = ...,
        **kwargs: Any,
    ) -> None: ...
    def get_target(self, *, step: int, metrics: Any, **kwargs) -> None: ...  # type: ignore[override]
    @property
    def in_cooldown(self) -> bool: ...
    def is_better(self, a: Any, best: Any) -> bool: ...


class CyclicLR(Scheduler):
    step_ratio: float = ...
    mode: str = ...
    gamma: float = ...
    scale_mode: str = ...
    cycle_momentum: bool = ...
    def __init__(
        self,
        optimizer: Optimizer,
        max_lr: Union[float, Sequence[float]],
        base_lr: Optional[Union[float, Sequence[float]]],
        param_group: Optional[Sequence[Dict[str, Any]]] = ...,
        step_size_up: int = ...,
        step_size_down: Optional[int] = ...,
        mode: str = ...,
        gamma: float = ...,
        scale_fn: Optional[Callable[[float], float]] = ...,
        scale_mode: str = ...,
        cycle_momentum: bool = ...,
        base_momentum: Optional[Union[float, Sequence[float]]] = ...,
        max_momentum: Optional[Union[float, Sequence[float]]] = ...,
        last_step: int = ...,
    ) -> None: ...
    def scale_fn(self, x: Any) -> float: ...

class CosineAnnealingWarmRestarts(Scheduler):
    T_0: int = ...
    T_i: int = ...
    T_mult: int = ...
    eta_min: Union[int, float] = ...
    T_cur: Any = ...
    def __init__(
        self,
        optimizer: Optimizer,
        T_0: int,
        T_mult: int = ...,
        eta_min: Union[int, float] = ...,
        last_step: int = ...,
        **kwargs: Any,
    ) -> None: ...

class OneCycleLR(Scheduler):
    anneal_func: Callable[[float, float, float], float] = ...
    use_beta1: bool = ...
    def __init__(
        self,
        optimizer: Optimizer,
        max_lr: Union[float, Sequence[float]],
        total_iters: Optional[int] = ...,
        epochs: Optional[int] = ...,
        steps_per_epoch: Optional[int] = ...,
        pct_start: float = ...,
        anneal_strategy: str = ...,
        cycle_momentum: bool = ...,
        base_momentum: Union[float, Sequence[float]] = ...,
        max_momentum: Union[float, Sequence[float]] = ...,
        div_factor: float = ...,
        final_div_factor: float = ...,
        three_phase: bool = ...,
        last_step: int = ...,
    ) -> None: ...

class PolynomialLR(Scheduler):
    power: float = ...
    def __init__(
        self,
        optimizer: Optimizer,
        power: float = ...,
        total_iters: int = ...,
        **kwargs: Any,
    ) -> None: ...
